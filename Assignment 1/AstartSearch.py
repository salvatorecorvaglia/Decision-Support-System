import random
import itertools
import collections
import time
start_time = time.time()


class Node:
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance
    - 'parent' is the preceding node generated by the solver, if any
    - 'action' is the action taken to produce puzzle, if any
    """
    def __init__(self, puzzle, parent=None, action=None):  # metodo di inizial. speciale invocato quando si crea un ogg.
        self.puzzle = puzzle
        self.parent = parent
        self.action = action

    @property  # Permette di considerare le variabili come se fossero dei metodi
    def state(self):  # Restituisce una rappresentazione che non varia nel tempo
        """
        Return a hashable representation of self
        """
        return str(self)

    @property
    def path(self):  # Restituisce tutto il percorso
        """
        Reconstruct a path from to the root 'parent'
        """
        node, p = self, []
        while node:
            p.append(node)
            node = node.parent
        yield from reversed(p)

    @property
    def solved(self):  # verifica se il puzzle è risolto (è stato raggiunto il goal)
        """ Wrapper to check if 'puzzle' is solved """
        return self.puzzle.solved

    @property
    def actions(self):  # fornisce le azioni accessibili dallo stato attuale
        """ Wrapper for 'actions' accessible at current state """
        return self.puzzle.actions

    @property
    def h1(self):
        goal = [1, 2, 3, 4, 5, 6, 7, 8, 0]
        count = 0
        count1 = 0  # Il numero di tasselli fuori posto
        for item in self.puzzle:
            if item != goal[count] and item != 0:
                 count1 = count1+1
            count = count + 1
        return count1

    @property
    def manhattan_distance(self): #Distanza di manhattan (h2)

        coord = [[2, 2], [0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1]]  # coordinate Goal

        distance = 0

        matrice = self.puzzle.board

        for x in range(3):
            for y in range(3):
                value = matrice[x][y]
                if value != 0:
                    x_goal = coord[value][0]  #Coordinate Goal
                    y_goal = coord[value][1]
                    distance += abs(x - x_goal) + abs(y - y_goal)  # Formula calcolo distanza di manhattan
        return distance

    @property
    def fn(self):  # costo totale = > Fn = g(n) + h(n)
        a = list(self.path)  # self.path restituisce un generatore per il quale non è possibile calcolare la lunghezza
        # cost = len(a) + self.h1
        cost = len(a) + self.manhattan_distance
        return cost

    def __str__(self):
        return str(self.puzzle)


class Solver:
    """
    An '8-puzzle' solver
    - 'start' is a Puzzle instance
    """
    def __init__(self, start): # Start è una istanza della classe Puzzle
        self.start = start

    def solve(self):
        """
        Perform breadth first search and return a path
        to the solution, if it exists
        """
        queue = collections.deque([Node(self.start)])  # Lista Open = stati non ancora visitati
        seen  = set()  # lista closed...contiene gli stati già visitati. IL metodo set() genera una lista senza ripetizioni
        seen.add(queue[0].state)
        while queue:
            # node = queue.pop()   # queue.pop() preleva un elemento da destra dalla lista queue (che viene riempita da sinistra verso destra)
            # questo significa che l'elemento più a destra è il primo elemento che è stato inserito
            node = queue.popleft() # così facendo otteniamo la Depth First Search (LIFO)
            if node.solved:
                return node.path

            for move, action in node.actions:
                child = Node(move(), node, action)

                if child.state not in seen:
                    queue.appendleft(child)  #LIFO
                    # queue.append(child) #FIFO
                    seen.add(child.state)
            a = list(queue)  # trasformiamo la deque in lista per utilizzare il metodo sorted
            b = sorted(a, key=lambda node: node.fn)  # permette di ordinare la lista open in funzione del costo Fn
            queue = collections.deque(b)


class Puzzle:
    """
    A class representing an '8-puzzle'.
    - 'board' should be a square list of lists with integer entries 0...width^2 - 1
       e.g. [[1,2,3],[4,0,6],[7,5,8]]
    """
    def __init__(self, board):
        self.width = len(board[0])  # len(board[0]) = 3 perchè restituisce la lunghezza del primo elemento della matrice 'board'
        self.board = board

    @property
    def solved(self):
        """
        The puzzle is solved if the flattened board's numbers are in
        increasing order from left to right and the '0' tile is in the
        last position on the board
        """
        N = self.width * self.width  # width corrisponde alla lunghezza della prima riga della matrice 3*3 considerata
        return str(self) == ''.join(map(str, range(1,N))) + '0' # 1234567480 è il goal
    # ''.join(sequence) viene utilizzato per la concatenazione di una serie di stringhe
    # map applica una data funzione a tutti gli oggetti di una lista data in input ...map(function_to_apply, list_of_inputs)

    @property
    def actions(self):
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'action'.
        """
        def create_move(at, to):
            return lambda: self._move(at, to)  # lambda è un cotrutto per la definizione una funzione anonima

        moves = []
        for i, j in itertools.product(range(self.width),
                                      range(self.width)):
            direcs = {'R': (i, j-1),
                      'L': (i, j+1),
                      'D': (i-1, j),
                      'U': (i+1, j)}

            for action, (r, c) in direcs.items():
                if r >= 0 and c >= 0 and r < self.width and c < self.width and \
                   self.board[r][c] == 0:
                    move = create_move((i,j), (r,c)), action
                    moves.append(move)
        return moves

    def shuffle(self):
        """
        Return a new puzzle that has been shuffled with 1000 random moves
        """
        puzzle = self
        for _ in range(1000):
            puzzle = random.choice(puzzle.actions)[0]()
        return puzzle

    def copy(self):
        """
        Return a new puzzle with the same board as 'self'
        """
        board = []
        for row in self.board:
            board.append([x for x in row])
        return Puzzle(board)

    def _move(self, at, to):
        """
        Return a new puzzle where 'at' and 'to' tiles have been swapped.
        NOTE: all moves should be 'actions' that have been executed
        """
        copy = self.copy()  # restituisce una copia
        i, j = at
        r, c = to
        copy.board[i][j], copy.board[r][c] = copy.board[r][c], copy.board[i][j]
        return copy

    def pprint(self):
        for row in self.board:
            print(row)
        print()

    def __str__(self):
        return ''.join(map(str, self))

    def __iter__(self):
        for row in self.board:
            yield from row


# example of use
board = [[1, 2, 3], [4, 0, 6], [7, 5, 8]]

puzzle = Puzzle(board)
puzzle = puzzle.shuffle()
s = Solver(puzzle)
p = s.solve()

for node in p:
    print("Il numero di tasselli fuori posto è:", node.h1)
    print("La distanza di manhattan è:", node.manhattan_distance)
    print("La Fn è:", node.fn)
    print(node.action)
    node.puzzle.pprint()


print("Tempo esecuzione: %s secondi" %(time.time() - start_time))
# print("--- %s seconds ---" % (time.time() - start_time))
